using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;
using System.Security.Cryptography;
using System.Text;
using System.Xml;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.VisualBasic;

namespace FileHelpers.Dynamic
{
    /// <summary>The MAIN class to work with runtime defined records.</summary>
    public abstract class ClassBuilder
    {
        //---------------------
        //->  STATIC METHODS

        #region LoadFromString

        /// <summary>Compiles the source code passed and returns the FIRST Type of the assembly. (Code in C#)</summary>
        /// <param name="classStr">The Source Code of the class in C#</param>
        /// <returns>The Type generated by runtime compilation of the class source.</returns>
        public static Type ClassFromString(string classStr)
        {
            return ClassFromString(classStr, "");
        }

        /// <summary>Compiles the source code passed and returns the FIRST Type of the assembly.</summary>
        /// <param name="classStr">The Source Code of the class in the specified language</param>
        /// <returns>The Type generated by runtime compilation of the class source.</returns>
        /// <param name="lang">One of the .NET Languages</param>
        public static Type ClassFromString(string classStr, NetLanguage lang)
        {
            return ClassFromString(classStr, "", lang);
        }

        /// <summary>Compiles the source code passed and returns the Type with the name className. (Code in C#)</summary>
        /// <param name="classStr">The Source Code of the class in C#</param>
        /// <param name="className">The Name of the Type that must be returned</param>
        /// <returns>The Type generated by runtime compilation of the class source.</returns>
        public static Type ClassFromString(string classStr, string className)
        {
            return ClassFromString(classStr, className, NetLanguage.CSharp);
        }
        private static readonly List<string> mReferences = [];
        private static readonly object mReferencesLock = new();

        /// <summary>Compiles the source code passed and returns the Type with the name className.</summary>
        /// <param name="classStr">The Source Code of the class in the specified language</param>
        /// <param name="className">The Name of the Type that must be returned</param>
        /// <param name="lang">One of the .NET Languages</param>
        /// <param name="additionalReferences">List of assemblies to be added in the dynamic compilation </param>
        /// <returns>The Type generated by runtime compilation of the class source.</returns>
        public static Type ClassFromString(string classStr, string className, NetLanguage lang, List<Assembly> additionalReferences = null)
        {
            if (classStr.Length < 4)
            {
                throw new BadUsageException("There is not enough text to be a proper class, load your class and try again");
            }

            StringBuilder code = new();

            switch (lang)
            {
                case NetLanguage.CSharp:
                    code.Append("using System; using FileHelpers; using System.Collections; using System.Collections.Generic;");
                    break;

                case NetLanguage.VbNet:
                    code.AppendLine("Imports System");
                    code.AppendLine("Imports FileHelpers");
                    break;
            }

            code.Append(classStr);

            List<MetadataReference> references = [];

            lock (mReferencesLock)
            {
                if (mReferences.Count == 0)
                {
                    foreach (Assembly loadedAssembly in AppDomain.CurrentDomain.GetAssemblies())
                    {
                        try
                        {
                            if (!loadedAssembly.IsDynamic && !string.IsNullOrEmpty(loadedAssembly.Location))
                            {
                                mReferences.Add(loadedAssembly.Location);
                            }
                        }
                        catch (NotSupportedException)
                        {
                            // Skip the assemblies that do not have a location (e.g., dynamic assemblies)
                        }
                    }
                }

                references.AddRange(mReferences.Select(r => MetadataReference.CreateFromFile(r)));
            }

            if (additionalReferences != null)
            {
                references.AddRange(additionalReferences.Select(r => MetadataReference.CreateFromFile(r.Location)));
            }

            SyntaxTree syntaxTree = lang switch
            {
                NetLanguage.CSharp => CSharpSyntaxTree.ParseText(code.ToString()),
                NetLanguage.VbNet => VisualBasicSyntaxTree.ParseText(code.ToString()),
                _ => throw new ArgumentOutOfRangeException(nameof(lang), lang, null),
            };

            
            Compilation compilation;
            switch (lang)
            {
                case NetLanguage.CSharp:
                    syntaxTree = CSharpSyntaxTree.ParseText(code.ToString());
                    compilation = CSharpCompilation.Create($"{Guid.NewGuid()}.dll")
                        .WithOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary))
                        .AddReferences(references)
                        .AddSyntaxTrees(syntaxTree);
                    break;

                case NetLanguage.VbNet:
                    syntaxTree = VisualBasicSyntaxTree.ParseText(code.ToString());
                    compilation = VisualBasicCompilation.Create($"{Guid.NewGuid()}.dll")
                        .WithOptions(new VisualBasicCompilationOptions(OutputKind.DynamicallyLinkedLibrary))
                        .AddReferences(references)
                        .AddSyntaxTrees(syntaxTree);
                    break;

                default:
                    throw new ArgumentOutOfRangeException(nameof(lang), lang, null);
            }

            using MemoryStream ms = new();
            Microsoft.CodeAnalysis.Emit.EmitResult result = compilation.Emit(ms);

            if (!result.Success)
            {
                IEnumerable<string> errors = result.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error)
                    .Select(d => $"Line {d.Location.GetLineSpan().StartLinePosition.Line + 1}: {d.GetMessage()}");
                throw new Exception($"Error Compiling Expression:\n{string.Join("\n", errors)}");
            }

            ms.Seek(0, SeekOrigin.Begin);
            Assembly assembly = AssemblyLoadContext.Default.LoadFromStream(ms);

            return !string.IsNullOrEmpty(className)
                ? assembly.GetType(className, true, true)
                : assembly.GetTypes().FirstOrDefault(t => !t.FullName.StartsWith("My.My") && t.IsDefined(typeof(TypedRecordAttribute), false));
        }


        #endregion

        #region CreateFromFile

        /// <summary>
        /// Create a class from a source file.
        /// </summary>
        /// <param name="filename">The filename with the source of the class.</param>
        /// <returns>The compiled class.</returns>
        public static Type ClassFromSourceFile(string filename)
        {
            return ClassFromSourceFile(filename, "");
        }

        /// <summary>
        /// Create a class from a source file.
        /// </summary>
        /// <param name="filename">The filename with the source of the class.</param>
        /// <param name="lang">The language used to compile the class.</param>
        /// <returns>The compiled class.</returns>
        public static Type ClassFromSourceFile(string filename, NetLanguage lang)
        {
            return ClassFromSourceFile(filename, "", lang);
        }

        /// <summary>
        /// Create a class from a source file.
        /// </summary>
        /// <param name="filename">The filename with the source of the class.</param>
        /// <param name="className">The name of the class to return.</param>
        /// <returns>The compiled class.</returns>
        public static Type ClassFromSourceFile(string filename, string className)
        {
            return ClassFromSourceFile(filename, className, NetLanguage.CSharp);
        }

        /// <summary>
        /// Create a class from a source file.
        /// </summary>
        /// <param name="filename">The filename with the source of the class.</param>
        /// <param name="className">The name of the class to return.</param>
        /// <param name="lang">The language used to compile the class.</param>
        /// <returns>The compiled class.</returns>
        public static Type ClassFromSourceFile(string filename, string className, NetLanguage lang)
        {
            StreamReader reader = new(filename);
            string classDef = reader.ReadToEnd();
            reader.Close();

            return ClassFromString(classDef, className, lang);
        }

        #endregion

        public List<Assembly> AdditionalReferences { get; private set; }

        #region SaveToFile

        /// <summary>Write the source code of the current class to a file. (In C#)</summary>
        /// <param name="filename">The file to write to.</param>
        public void SaveToSourceFile(string filename)
        {
            SaveToSourceFile(filename, NetLanguage.CSharp);
        }

        /// <summary>Write the source code of the current class to a file. (In the specified language)</summary>
        /// <param name="filename">The file to write to.</param>
        /// <param name="lang">The .NET Language used to write the source code.</param>
        public void SaveToSourceFile(string filename, NetLanguage lang)
        {
            StreamWriter writer = new(filename);
            writer.Write(GetClassSourceCode(lang));
            writer.Close();
        }

        /// <summary>Write the ENCRYPTED source code of the current class to a file. (In C#)</summary>
        /// <param name="filename">The file to write to.</param>
        public void SaveToBinaryFile(string filename)
        {
            SaveToBinaryFile(filename, NetLanguage.CSharp);
        }

        /// <summary>Write the ENCRYPTED source code of the current class to a file. (In C#)</summary>
        /// <param name="filename">The file to write to.</param>
        /// <param name="lang">The .NET Language used to write the source code.</param>
        public void SaveToBinaryFile(string filename, NetLanguage lang)
        {
            StreamWriter writer = new(filename);
            writer.Write(GetClassBinaryCode(lang));
            writer.Close();
        }

        #endregion

        /// <summary>
        /// Create a class with 'classname'
        /// </summary>
        /// <param name="className">Name of class to create</param>
        internal ClassBuilder(string className)
        {
            className = className.Trim();
            if (ValidIdentifierValidator.ValidIdentifier(className) == false)
            {
                throw new FileHelpersException($"The string '{className}' is not a valid .NET identifier");
            }

            mClassName = className;
            AdditionalReferences = [];
        }

        /// <summary>Generate the runtime record class to be used by the engines.</summary>
        /// <returns>The generated record class</returns>
        public Type CreateRecordClass()
        {
            string classCode = GetClassSourceCode(NetLanguage.CSharp);
            return ClassFromString(classCode, "", NetLanguage.CSharp, AdditionalReferences);
        }

        #region Fields

        /// <summary>Removes all the Fields of the current class.</summary>
        public void ClearFields()
        {
            mFields.Clear();
        }

        /// <summary>
        /// List of all the fields in the class
        /// </summary>
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        internal ArrayList mFields = [];

        /// <summary>
        /// Add a field to the class
        /// </summary>
        /// <param name="field">Field details to add</param>
        internal void AddFieldInternal(FieldBuilder field)
        {
            field.mFieldIndex = mFields.Add(field);
            field.mClassBuilder = this;
        }

        /// <summary>Returns the current fields of the class.</summary>
        public FieldBuilder[] Fields
        {
            get { return (FieldBuilder[])mFields.ToArray(typeof(FieldBuilder)); }
        }

        /// <summary>Returns the current number of fields.</summary>
        public int FieldCount
        {
            get { return mFields.Count; }
        }

        /// <summary>Return the field at the specified index.</summary>
        /// <param name="index">The index of the field.</param>
        /// <returns>The field at the specified index.</returns>
        public FieldBuilder FieldByIndex(int index)
        {
            return (FieldBuilder)mFields[index];
        }

        #endregion

        #region ClassName

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private string mClassName;

        /// <summary>Gets or sets the name of the Class.</summary>
        public string ClassName
        {
            get { return mClassName; }
            set { mClassName = value; }
        }

        #endregion

        //----------------------------
        //->  ATTRIBUTE MAPPING

        #region IgnoreFirstLines

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private int mIgnoreFirstLines = 0;

        /// <summary>Indicates the number of FIRST LINES or heading records to be ignored by the engines.</summary>
        public int IgnoreFirstLines
        {
            get { return mIgnoreFirstLines; }
            set { mIgnoreFirstLines = value; }
        }

        #endregion

        #region IgnoreLastLines

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private int mIgnoreLastLines = 0;

        /// <summary>Indicates the number of LAST LINES or trailing records to be ignored by the engines.</summary>
        public int IgnoreLastLines
        {
            get { return mIgnoreLastLines; }
            set { mIgnoreLastLines = value; }
        }

        #endregion

        #region IgnoreEmptyLines

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private bool mIgnoreEmptyLines = false;

        /// <summary>Indicates that the engines must ignore the empty lines in the files.</summary>
        public bool IgnoreEmptyLines
        {
            get { return mIgnoreEmptyLines; }
            set { mIgnoreEmptyLines = value; }
        }

        #endregion

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private bool mGenerateProperties = false;

        /// <summary>Indicates if this ClassBuilder generates also the property accessors (Perfect for DataBinding)</summary>
        public bool GenerateProperties
        {
            get { return mGenerateProperties; }
            set { mGenerateProperties = value; }
        }

        /// <summary>
        /// Returns the ENCRYPTED code for the current class in the specified language.
        /// </summary>
        /// <param name="lang">The language for the return code.</param>
        /// <returns>The ENCRYPTED code for the class that are currently building.</returns>
        public string GetClassBinaryCode(NetLanguage lang)
        {
            return Encrypt(GetClassSourceCode(lang), "withthefilehelpers1.0.0youcancodewithoutproblems1.5.0");
        }

        /// <summary>
        /// Returns the source code for the current class in the specified language.
        /// </summary>
        /// <param name="lang">The language for the return code.</param>
        /// <returns>The Source Code for the class that are currently building.</returns>
        public string GetClassSourceCode(NetLanguage lang)
        {
            ValidateClass();

            StringBuilder sb = new(100);

            BeginNamespace(lang, sb);

            AttributesBuilder attbs = new(lang);

            AddAttributesInternal(attbs);
            AddAttributesCode(attbs, lang);

            sb.Append(attbs.GetAttributesCode());

            switch (lang)
            {
                case NetLanguage.VbNet:
                    sb.Append(GetVisibility(lang, mVisibility) + GetSealed(lang) + "Class " + mClassName);
                    sb.Append(Environment.NewLine);
                    break;
                case NetLanguage.CSharp:
                    sb.Append(GetVisibility(lang, mVisibility) + GetSealed(lang) + "class " + mClassName);
                    sb.Append(Environment.NewLine);
                    sb.Append('{');
                    break;
            }

            sb.Append(Environment.NewLine);
            sb.Append(Environment.NewLine);

            foreach (FieldBuilder field in mFields)
            {
                sb.Append(field.GetFieldCode(lang));
                sb.Append(Environment.NewLine);
            }

            sb.Append(Environment.NewLine);

            switch (lang)
            {
                case NetLanguage.VbNet:
                    sb.Append("End Class");
                    break;
                case NetLanguage.CSharp:
                    sb.Append('}');
                    break;
            }

            EndNamespace(lang, sb);

            return sb.ToString();
        }

        private void ValidateClass()
        {
            if (ClassName.Trim().Length == 0)
                throw new FileHelpersException("The ClassName can't be empty");

            for (int i = 0; i < mFields.Count; i++)
            {
                if (((FieldBuilder)mFields[i]).FieldName.Trim().Length == 0)
                {
                    throw new FileHelpersException($"The {i + 1}th field name can't be empty");
                }

                if (((FieldBuilder)mFields[i]).FieldType.Trim().Length == 0)
                {
                    throw new FileHelpersException($"The {i + 1}th field type can't be empty");
                }
            }
        }

        /// <summary>
        /// Store the attributes for adding when we write the code to text
        /// </summary>
        /// <param name="attbs">Where attributes are stored</param>
        /// <param name="lang"></param>
        internal abstract void AddAttributesCode(AttributesBuilder attbs, NetLanguage lang);

        private void AddAttributesInternal(AttributesBuilder attbs)
        {
            if (mIgnoreFirstLines != 0)
                attbs.AddAttribute("IgnoreFirst(" + mIgnoreFirstLines.ToString() + ")");

            if (mIgnoreLastLines != 0)
                attbs.AddAttribute("IgnoreLast(" + mIgnoreLastLines.ToString() + ")");

            if (mIgnoreEmptyLines)
                attbs.AddAttribute("IgnoreEmptyLines()");

            if (mRecordConditionInfo.Condition != FileHelpers.RecordCondition.None)
            {
                attbs.AddAttribute("ConditionalRecord(RecordCondition." + mRecordConditionInfo.Condition.ToString() +
                                   ", \"" + mRecordConditionInfo.Selector + "\")");
            }

            if (!string.IsNullOrEmpty(mIgnoreCommentInfo.CommentMarker))
            {
                attbs.AddAttribute("IgnoreCommentedLines(\"" + mIgnoreCommentInfo.CommentMarker + "\", " +
                                   mIgnoreCommentInfo.InAnyPlace.ToString().ToLower() + ")");
            }
        }

        #region "  EncDec  "

        private static byte[] Encrypt(byte[] clearData, byte[] key, byte[] iv)
        {
            using MemoryStream ms = new();
            using Aes aes = Aes.Create();
            aes.Key = key;
            aes.IV = iv;

            using (CryptoStream cs = new(ms, aes.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cs.Write(clearData, 0, clearData.Length);
            }

            byte[] encryptedData = ms.ToArray();
            return encryptedData;
        }


        private static string Encrypt(string clearText, string Password)
        {
            byte[] clearBytes = Encoding.Unicode.GetBytes(clearText);

            using PasswordDeriveBytes pdb = new(Password,
                "Ivan Medvedev"u8.ToArray());
            byte[] encryptedData = Encrypt(clearBytes,
                pdb.GetBytes(32),
                pdb.GetBytes(16));

            return Convert.ToBase64String(encryptedData);
        }

        // Decrypt a byte array into a byte array using a key and an IV 
        //private static byte[] Decrypt(byte[] cipherData, byte[] key, byte[] iv)
        //{
        //    using MemoryStream ms = new();
        //    using Aes aes = Aes.Create();
        //    aes.Key = key;
        //    aes.IV = iv;

        //    using (CryptoStream cs = new(ms, aes.CreateDecryptor(), CryptoStreamMode.Write))
        //    {
        //        cs.Write(cipherData, 0, cipherData.Length);
        //    }

        //    byte[] decryptedData = ms.ToArray();
        //    return decryptedData;
        //}


        //private static string Decrypt(string cipherText, string password)
        //{
        //    byte[] cipherBytes = Convert.FromBase64String(cipherText);
        //    using PasswordDeriveBytes pdb = new(password,
        //        new byte[] {
        //            0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64,
        //            0x65, 0x76
        //        });
        //    byte[] decryptedData = Decrypt(cipherBytes, pdb.GetBytes(32), pdb.GetBytes(16));
        //    return Encoding.Unicode.GetString(decryptedData);
        //}

        #endregion

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private string mCommentText = null;

        /// <summary>Comment text placed above the class definition</summary>
        public string CommentText
        {
            get { return mCommentText; }
            set { mCommentText = value; }
        }

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private NetVisibility mVisibility = NetVisibility.Public;

        /// <summary>The Visibility for the class.</summary>
        public NetVisibility Visibility
        {
            get { return mVisibility; }
            set { mVisibility = value; }
        }

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private bool mSealedClass = true;

        /// <summary>Indicates if the generated class must be sealed.</summary>
        public bool SealedClass
        {
            get { return mSealedClass; }
            set { mSealedClass = value; }
        }

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private string mNamespace = "";

        /// <summary>The namespace used when creating the class.</summary>
        public string Namespace
        {
            get { return mNamespace; }
            set { mNamespace = value; }
        }

        /// <summary>
        /// Convert visibility type to word needed by the language
        /// </summary>
        /// <param name="lang">Language C# or Visual Basic</param>
        /// <param name="visibility">Public,  internal, protected, etc</param>
        /// <returns>Visibility correct for the language</returns>
        internal static string GetVisibility(NetLanguage lang, NetVisibility visibility)
        {
            switch (lang)
            {
                case NetLanguage.CSharp:
                    switch (visibility)
                    {
                        case NetVisibility.Public:
                            return "public ";
                        case NetVisibility.Private:
                            return "private ";
                        case NetVisibility.Internal:
                            return "internal ";
                        case NetVisibility.Protected:
                            return "protected ";
                    }
                    break;

                case NetLanguage.VbNet:
                    switch (visibility)
                    {
                        case NetVisibility.Public:
                            return "Public ";
                        case NetVisibility.Private:
                            return "Private ";
                        case NetVisibility.Internal:
                            return "Friend ";
                        case NetVisibility.Protected:
                            return "Protected ";
                    }
                    break;
            }

            return "";
        }

        /// <summary>
        /// Get the sealed prefix,  if needed
        /// </summary>
        /// <param name="lang">Language we are writing in</param>
        /// <returns>nothing, sealed or NotInheritable</returns>
        private string GetSealed(NetLanguage lang)
        {
            if (!mSealedClass)
                return "";

            return lang switch
            {
                NetLanguage.CSharp => "sealed ",
                NetLanguage.VbNet => "NotInheritable ",
                _ => "",
            };
        }

        /// <summary>
        /// Add the namespace to the class details
        /// </summary>
        /// <param name="lang">Language type we are generating</param>
        /// <param name="sb">class text</param>
        private void BeginNamespace(NetLanguage lang, StringBuilder sb)
        {
            if (string.IsNullOrEmpty(mNamespace))
                return;

            switch (lang)
            {
                case NetLanguage.CSharp:
                    sb.Append("namespace ");
                    sb.Append(mNamespace);
                    sb.Append(Environment.NewLine);
                    sb.Append('{');
                    break;

                case NetLanguage.VbNet:
                    sb.Append("Namespace ");
                    sb.Append(mNamespace);
                    sb.Append(Environment.NewLine);
                    break;
            }

            sb.Append(Environment.NewLine);
        }

        /// <summary>
        /// Add the end of namespace to text
        /// </summary>
        /// <param name="lang">language we are generating</param>
        /// <param name="sb">class text to add to</param>
        private void EndNamespace(NetLanguage lang, StringBuilder sb)
        {
            if (string.IsNullOrEmpty(mNamespace))
                return;

            sb.Append(Environment.NewLine);

            switch (lang)
            {
                case NetLanguage.CSharp:
                    sb.Append('}');
                    break;

                case NetLanguage.VbNet:
                    sb.Append("End Namespace");
                    break;
            }
        }

        /// <summary>
        /// Loads the XML representation of a ClassBuilder inheritor and return it. (for XML saved with SaveToXml method)
        /// </summary>
        /// <remarks>
        /// ClassBuilder inheritors: <see cref="DelimitedClassBuilder"/> or <see cref="FixedLengthClassBuilder"/>
        /// </remarks>
        /// <param name="xml">The XML representation of the record class.</param>
        /// <returns>A new instance of a ClassBuilder inheritor: <see cref="DelimitedClassBuilder"/> or <see cref="FixedLengthClassBuilder"/> </returns>
        public static ClassBuilder LoadFromXmlString(string xml)
        {
            XmlDocument document = new();
            document.Load(new StringReader(xml));

            return LoadFromXml(document);
        }

        /// <summary>
        /// Loads the XML representation of a ClassBuilder inheritor and return it. (for XML saved with SaveToXml method)
        /// </summary>
        /// <remarks>
        /// ClassBuilder inheritors: <see cref="DelimitedClassBuilder"/> or <see cref="FixedLengthClassBuilder"/>
        /// </remarks>
        /// <param name="document">The XML document with the representation of the record class.</param>
        /// <returns>A new instance of a ClassBuilder inheritor: <see cref="DelimitedClassBuilder"/> or <see cref="FixedLengthClassBuilder"/> </returns>
        public static ClassBuilder LoadFromXml(XmlDocument document)
        {
            ClassBuilder res;

            string classtype = document.DocumentElement.LocalName;

            if (classtype == "DelimitedClass")
                res = DelimitedClassBuilder.LoadXmlInternal(document);
            else
                res = FixedLengthClassBuilder.LoadXmlInternal(document);

            XmlNode node = document.DocumentElement["IgnoreLastLines"];
            if (node != null)
                res.IgnoreLastLines = int.Parse(node.InnerText);

            node = document.DocumentElement["IgnoreFirstLines"];
            if (node != null)
                res.IgnoreFirstLines = int.Parse(node.InnerText);

            node = document.DocumentElement["IgnoreEmptyLines"];
            if (node != null)
                res.IgnoreEmptyLines = true;

            node = document.DocumentElement["CommentMarker"];
            if (node != null)
                res.IgnoreCommentedLines.CommentMarker = node.InnerText;

            node = document.DocumentElement["CommentInAnyPlace"];
            if (node != null)
                res.IgnoreCommentedLines.InAnyPlace = bool.Parse(node.InnerText.ToLower());

            node = document.DocumentElement["SealedClass"];
            res.SealedClass = node != null;

            node = document.DocumentElement["Namespace"];
            if (node != null)
                res.Namespace = node.InnerText;

            node = document.DocumentElement["Visibility"];
            if (node != null)
                res.Visibility = (NetVisibility)Enum.Parse(typeof(NetVisibility), node.InnerText);

            node = document.DocumentElement["RecordCondition"];
            if (node != null)
                res.RecordCondition.Condition = (RecordCondition)Enum.Parse(typeof(RecordCondition), node.InnerText);

            node = document.DocumentElement["RecordConditionSelector"];
            if (node != null)
                res.RecordCondition.Selector = node.InnerText;

            node = document.DocumentElement["CommentText"];
            if (node != null)
                res.CommentText = node.InnerText;

            res.ReadClassElements(document);

            node = document.DocumentElement["Fields"];
            XmlNodeList nodes;

            if (classtype == "DelimitedClass")
                nodes = node.SelectNodes("/DelimitedClass/Fields/Field");
            else
                nodes = node.SelectNodes("/FixedLengthClass/Fields/Field");

            foreach (XmlNode n in nodes)
                res.ReadField(n);

            return res;
        }

        /// <summary>
        /// Loads the XML representation of a ClassBuilder inheritor and return it. (for XML saved with SaveToXml method)
        /// </summary>
        /// <remarks>
        /// ClassBuilder inheritors: <see cref="DelimitedClassBuilder"/> or <see cref="FixedLengthClassBuilder"/>
        /// </remarks>
        /// <param name="filename">A file with the XML representation of the record class.</param>
        /// <returns>A new instance of a ClassBuilder inheritor: <see cref="DelimitedClassBuilder"/> or <see cref="FixedLengthClassBuilder"/> </returns>
        public static ClassBuilder LoadFromXml(string filename)
        {
            XmlDocument document = new();
            document.Load(filename);

            return LoadFromXml(document);
        }

        /// <summary>
        /// Creates the XML representation of the current record class.
        /// </summary>
        /// <returns>The representation of the current record class as xml string.</returns>
        public string SaveToXmlString()
        {
            StringBuilder sb = new();

            using (StringWriter writer = new(sb))
                SaveToXml(writer);

            return sb.ToString();
        }

        /// <summary>
        /// Saves to a file the XML representation of the current record class.
        /// </summary>
        /// <param name="filename">A file name to write to.</param>
        public void SaveToXml(string filename)
        {
            using FileStream stream = new(filename, FileMode.Create);
            SaveToXml(stream);
        }

        /// <summary>
        /// Saves to an Stream the XML representation of the current record class.
        /// </summary>
        /// <param name="stream">Stream to be written.</param>
        public void SaveToXml(Stream stream)
        {
            using TextWriter writer = new StreamWriter(stream);
            SaveToXml(writer);
        }

        /// <summary>
        /// Save to a TextWriter the XML representation of the current record class.
        /// </summary>
        /// <param name="writer">The TextWriter for the output Stream.</param>
        public void SaveToXml(TextWriter writer)
        {
            XmlHelper xml = new();

            xml.BeginWriteStream(writer);

            WriteHeaderElement(xml);

            xml.WriteElement("ClassName", ClassName);
            xml.WriteElement("Namespace", Namespace, "");

            xml.WriteElement("SealedClass", SealedClass);
            xml.WriteElement("Visibility", Visibility.ToString(), "Public");

            xml.WriteElement("IgnoreEmptyLines", IgnoreEmptyLines);
            xml.WriteElement("IgnoreFirstLines", IgnoreFirstLines.ToString(), "0");
            xml.WriteElement("IgnoreLastLines", IgnoreLastLines.ToString(), "0");

            xml.WriteElement("CommentMarker", IgnoreCommentedLines.CommentMarker, "");
            xml.WriteElement("CommentInAnyPlace",
                IgnoreCommentedLines.InAnyPlace.ToString().ToLower(),
                true.ToString().ToLower());

            xml.WriteElement("RecordCondition", RecordCondition.Condition.ToString(), "None");
            xml.WriteElement("RecordConditionSelector", RecordCondition.Selector, "");

            WriteExtraElements(xml);

            xml.Writer.WriteStartElement("Fields");

            for (int i = 0; i < mFields.Count; i++)
                ((FieldBuilder)mFields[i]).SaveToXml(xml);

            xml.Writer.WriteEndElement();

            xml.Writer.WriteEndElement();
            xml.EndWrite();
        }

        /// <summary>
        /// write header information for this class
        /// </summary>
        /// <param name="writer">writer to write on</param>
        internal abstract void WriteHeaderElement(XmlHelper writer);

        /// <summary>
        /// write any extra information for the class
        /// </summary>
        /// <param name="writer">writer to put xml on</param>
        internal abstract void WriteExtraElements(XmlHelper writer);

        /// <summary>
        /// read class elements from xml document
        /// </summary>
        /// <param name="document">document to read from</param>
        internal abstract void ReadClassElements(XmlDocument document);

        /// <summary>
        /// read attribute information for class
        /// </summary>
        /// <param name="node"></param>
        internal abstract void ReadField(XmlNode node);

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly RecordConditionInfo mRecordConditionInfo = new();

        /// <summary>Allow to tell the engine what records must be included or excluded while reading.</summary>
        public RecordConditionInfo RecordCondition
        {
            get { return mRecordConditionInfo; }
        }

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private readonly IgnoreCommentInfo mIgnoreCommentInfo = new();

        /// <summary>Indicates that the engine must ignore the lines with this comment marker.</summary>
        public IgnoreCommentInfo IgnoreCommentedLines
        {
            get { return mIgnoreCommentInfo; }
        }

        /// <summary>Allow to tell the engine what records must be included or excluded while reading.</summary>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public sealed class RecordConditionInfo
        {
            internal RecordConditionInfo() { }

            private RecordCondition mRecordCondition = FileHelpers.RecordCondition.None;

            /// <summary>Allow to tell the engine what records must be included or excluded while reading.</summary>
            public RecordCondition Condition
            {
                get { return mRecordCondition; }
                set { mRecordCondition = value; }
            }

            private string mRecordConditionSelector = "";

            /// <summary>The selector used by the <see cref="RecordCondition"/>.</summary>
            public string Selector
            {
                get { return mRecordConditionSelector; }
                set { mRecordConditionSelector = value; }
            }
        }

        /// <summary>Indicates that the engine must ignore the lines with this comment marker.</summary>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public sealed class IgnoreCommentInfo
        {
            internal IgnoreCommentInfo() { }

            /// <summary>
            /// <para>Indicates that the engine must ignore the lines with this
            /// comment marker.</para>
            /// <para>An empty string or null indicates that the engine does
            /// not look for comments</para>
            /// </summary>
            public string CommentMarker
            {
                get { return mMarker; }
                set
                {
                    if (value != null)
                        value = value.Trim();

                    mMarker = value;
                }
            }

            private string mMarker = "";

            /// <summary>Indicates if the comment can have spaces or tabs at left (true by default)</summary>
            public bool InAnyPlace
            {
                get { return mInAnyPlace; }
                set { mInAnyPlace = value; }
            }

            private bool mInAnyPlace = true;
        }

        /// <summary>
        /// Break down a class into a generic or a full type name
        /// </summary>
        /// <param name="type">type to get type of</param>
        /// <returns>Type of the class as a string</returns>
        internal static string TypeToString(Type type)
        {
            if (type.IsGenericType)
            {
                StringBuilder sb = new();
                sb.Append(type.FullName.AsSpan(0, type.FullName.IndexOf('`')));
                sb.Append('<');

                Type[] args = type.GetGenericArguments();

                for (int i = 0; i < args.Length; i++)
                {
                    if (i > 0)
                        sb.Append(',');

                    sb.Append(TypeToString(args[i]));
                }
                sb.Append('>');

                return sb.ToString();
            }
            else
                return type.FullName;
        }
    }
}
